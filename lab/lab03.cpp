// –ù–∞–π—Ç–∏ —á–∏—Å–ª–µ–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ —É—Ä–∞–≤–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–º
// –≠–π–ª–µ—Ä–∞ –∏ –µ–≥–æ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è–º–∏ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ [0,1], —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–µ–µ –∑–∞–¥–∞–Ω–Ω–æ–º—É
// –Ω–∞—á–∞–ª—å–Ω–æ–º—É —É—Å–ª–æ–≤–∏—é. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ: n=5, 10, 20, 40,‚Ä¶ –ù–∞–π—Ç–∏
// –∞–±—Å–æ–ª—é—Ç–Ω—É—é –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–µ—Ç–æ–¥–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º —à–∞–≥–µ
// –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è.
// –î–ª—è –∫–∞–∂–¥–æ–≥–æ –º–µ—Ç–æ–¥–∞ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫–∏:
// –∞) –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è –∫—Ä–∏–≤–∞—è (—Ç–æ—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ) –∏ –ª–æ–º–∞–Ω—ã–µ –≠–π–ª–µ—Ä–∞
// –±) –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç–∏ (–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º —à–∞–≥–µ) –æ—Ç —à–∞–≥–∞.
// –°—Ä–∞–≤–Ω–∏—Ç—å –∏ –æ–±—ä—è—Å–Ω–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤. –ü–æ—á–µ–º—É
// —Å–æ–≤–ø–∞–ª–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è –ø–æ –ø–µ—Ä–≤–æ–π –∏ –≤—Ç–æ—Ä–æ–π –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è–º –º–µ—Ç–æ–¥–∞ –≠–π–ª–µ—Ä–∞?
// ---
// –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–≤—É—Ö—ç—Ç–∞–ø–Ω—ã–π –º–µ—Ç–æ–¥ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã. –ü—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ—Ç—å
// –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ ùõº. –í—ã—è—Å–Ω–∏—Ç—å, –ø—Ä–∏ –∫–∞–∫–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏
// –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ ùõº –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å –±—É–¥–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π.
// –§—É–Ω–∫—Ü–∏–∏:
// 1. y' = y - x, y(0) = n + 4
// 2. y' = y - 2x/y, y(0) = n + 4

#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include <iomanip>
#include <string>
using namespace std;

// –§—É–Ω–∫—Ü–∏–∏ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏ —É—Ä–∞–≤–Ω–µ–Ω–∏—è
double f1(double x, double y) {
    return y - x;
}

double f2(double x, double y) {
    if (y == 0) return 0; // –≤–æ –∏–∑–±–µ–∂–∞–Ω–∏–µ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0
    return y - (2 * x / y);
}

// –¢–æ—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ —É—Ä–∞–≤–Ω–µ–Ω–∏—è: y' = y - x, y(0) = y0
double exact1(double x, double y0) {
    return (y0 + 1) * exp(x) - x - 1;
}

// –ú–µ—Ç–æ–¥ –≠–π–ª–µ—Ä–∞
double euler(double (*f)(double, double), double x0, double y0, double h, int n) {
    double x = x0, y = y0;
    for (int i = 0; i < n; ++i) {
        y += h * f(x, y);
        x += h;
    }
    return y;
    // 
}

// –ü–µ—Ä–≤–∞—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –º–µ—Ç–æ–¥–∞ –≠–π–ª–µ—Ä–∞ (–ø—Ä–µ–¥–∏–∫—Ç–æ—Ä-–∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä)
double euler_mod1(double (*f)(double, double), double x0, double y0, double h, int n) {
    double x = x0, y = y0;
    for (int i = 0; i < n; ++i) {
        double y_pred = y + h * f(x, y);                     // –ü—Ä–µ–¥–∏–∫—Ç–æ—Ä
        y += h * f(x + h, y_pred);                           // –ö–æ—Ä—Ä–µ–∫—Ç–æ—Ä
        x += h;
    }
    return y;
}

// –í—Ç–æ—Ä–∞—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –º–µ—Ç–æ–¥–∞ –≠–π–ª–µ—Ä–∞ (—Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–π)
double euler_mod2(double (*f)(double, double), double x0, double y0, double h, int n) {
    double x = x0, y = y0;
    for (int i = 0; i < n; ++i) {
        double k1 = f(x, y);
        double k2 = f(x + h, y + h * k1);
        y += h * 0.5 * (k1 + k2);
        x += h;
    }
    return y;
}

// –ú–µ—Ç–æ–¥ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã 2-–≥–æ –ø–æ—Ä—è–¥–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º alpha
double runge_kutta_2(double (*f)(double, double), double x0, double y0, double h, int n, double alpha) {
    double x = x0, y = y0;
    double beta = 1.0 / (2.0 * alpha);
    for (int i = 0; i < n; ++i) {
        double k1 = f(x, y);
        double k2 = f(x + alpha * h, y + alpha * h * k1);
        y += h * ((1 - beta) * k1 + beta * k2);
        x += h;
    }
    return y;
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ CSV
void save_csv(const string& filename, const vector<double>& h_values, const vector<double>& errors, const string& method) {
    ofstream fout(filename);
    fout << "h,error_" << method << "\n";
    for (size_t i = 0; i < h_values.size(); ++i) {
        fout << h_values[i] << "," << errors[i] << "\n";
    }
    fout.close();
}

int main() {
    int choice;
    double (*f)(double, double);
    double (*exact)(double, double) = nullptr;

    cout << "–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ:\n";
    cout << "1. y' = y - x\n";
    cout << "2. y' = y - 2x/y\n";
    cin >> choice;

    int n_param;
    cout << "–í–≤–µ–¥–∏—Ç–µ n-–ø–∞—Ä–∞–º–µ—Ç—Ä (–¥–ª—è y(0) = n + 4): ";
    cin >> n_param;

    double y0 = n_param + 4;
    double x0 = 0.0, X = 1.0;

    if (choice == 1) {
        f = f1;
        exact = exact1;
    } else {
        f = f2;
    }

    vector<int> steps = {5, 10, 20, 40, 80, 160};
    vector<double> h_values, euler_errors, mod1_errors, mod2_errors, rk_errors;
    double alpha = 0.5; // –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ alpha –¥–ª—è –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã

    for (int n : steps) {
        double h = (X - x0) / n;
        double y_euler = euler(f, x0, y0, h, n);
        double y_mod1 = euler_mod1(f, x0, y0, h, n);
        double y_mod2 = euler_mod2(f, x0, y0, h, n);
        double y_rk    = runge_kutta_2(f, x0, y0, h, n, alpha);

        double y_exact = (exact != nullptr) ? exact(X, y0) : 0.0;

        h_values.push_back(h);

        if (exact != nullptr) {
            euler_errors.push_back(abs(y_exact - y_euler));
            mod1_errors.push_back(abs(y_exact - y_mod1));
            mod2_errors.push_back(abs(y_exact - y_mod2));
            rk_errors.push_back(abs(y_exact - y_rk));
        } else {
            euler_errors.push_back(0);
            mod1_errors.push_back(0);
            mod2_errors.push_back(0);
            rk_errors.push_back(0);
        }
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—à–∏–±–∫–∏ –≤ CSV
    save_csv("euler.csv", h_values, euler_errors, "euler");
    save_csv("mod1.csv", h_values, mod1_errors, "mod1");
    save_csv("mod2.csv", h_values, mod2_errors, "mod2");
    save_csv("rk.csv", h_values, rk_errors, "rk");

    // –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –æ—à–∏–±–∫–∏ –¥–ª—è –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã –ø—Ä–∏ —Ä–∞–∑–Ω—ã—Ö alpha
    if (exact != nullptr) {
        double min_error = 1e9;
        double best_alpha = 0.0;
        for (double a = 0.1; a <= 0.9; a += 0.01) {
            double err = abs(
                exact(X, y0) - runge_kutta_2(f, x0, y0, (X - x0) / 40, 40, a)
            );
            if (err < min_error) {
                min_error = err;
                best_alpha = a;
            }
        }
        cout << "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ alpha = " << best_alpha << ", –æ—à–∏–±–∫–∞ = " << min_error << endl;
    }

    cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ CSV —Ñ–∞–π–ª—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≤ Excel.\n";
    return 0;
}