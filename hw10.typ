#import "@preview/cetz:0.3.4"
#import "@preview/cetz-plot:0.1.1": plot, chart
#import "@preview/physica:0.9.5": *
#import "@preview/showybox:2.0.4": showybox
#import "@preview/fletcher:0.5.7": diagram, node, edge


#let SURNAME_NAME = "Никитин Илья"
#let UNN_GROUP = "3822Б1МА1"
#let n = 21


#set page(
  paper: "a4",
  margin: (top: 3em, rest: 0.8cm),
  numbering: "1 / 1",
  header: [
    ДЗ.10. Построение разностной схемы краевой задачи для ЛОДУ 2 порядка.
    #h(1fr)
    #eval(mode: "math", "n = " + repr(n))
    #h(1fr)
    #SURNAME_NAME, #UNN_GROUP
  ],
)
#set par(justify: true, first-line-indent: 2em)

//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#line(length: 100%)
Для численного решения задачи методом конечных разностей
область изменения переменной $x in [0, 1]$
разбить на три отрезка с шагом $h = 1 slash 3$,
полагая $x_0 = 0, x_n = x_0 + n h, n = overline(1\,3)$,
значения искомой функции в узлах сетки
обозначить $y_0, y_1, y_2, y_3$.

#let hh = (num: 1, denom: 3)

*№ 1.*
$""
  quad y'' +3 y' - 5 y = 2 x, x in [0,1]
  quad y(0) + 2y'(0) = 0,
  quad y(1) - y'(1) = 1.$

Запишем дифференциальный оператор и правую часть задачи:

$
  L y = cases(
    display(dv(y, x, 2) + 3 dv(y, x) - 5 y\, &quad x in (0,1))\;,
    display(y(0) + 2 dv(y, x)(0)\, &quad x = 0)\;,
    display(y(1) - dv(y, x)(1)\, &quad x = 1).,
  )
  quad quad quad
  f(x) = cases(
    display(2 x\, &quad x in (0,1))\;,
    0\, &quad x = 0\;,
    1\, &quad x = 1,
  )
$

Разобьем область изменения переменной $x in [0,3]$ на три отрезка:

#align(center)[
  #import cetz.draw
  #let tick(num, pos) = (
    pos: pos,
    draw: {
      draw.content((0, 40), $#num$, anchor: "south", padding: (bottom: 0.4))
      draw.line((90deg, -5), (90deg, +5))
      draw.content((0, 0), $y_#num$, anchor: "south", padding: (bottom: 0.4))
      draw.content(
        (0, 0),
        if str(hh.num * num / hh.denom).len() > 10 {
          $#(hh.num * num) slash #hh.denom$
        } else {
          $#(hh.num * num / hh.denom)$
        },
        anchor: "north",
        padding: (top: 0.4),
      )
      draw.content((0, -30), $x_#num$, anchor: "north", padding: (top: 0.4))
    },
  )
  #diagram(
    node((-0.56, -0.7))[Номера узлов],
    node((-0.7, -0.25))[Сеточная функция],
    node((-0.51, 0.754))[Переменная],
    edge(
      (0, 0.1),
      (12, 0.1),
      marks: (
        tick(0, 0.065),
        tick(1, 0.354),
        tick(2, 0.644),
        tick(3, 0.934),
        (inherit: "solid"),
      ),
    ),
  )
]

Составим разностную схему для уравнения во внутренних узлах сетки
используя центральные разности второго порядка аппроксимации:
$
  y''_n = frac(y_(n+1) - 2 y_n + y_(n-1), h^2) + O(h^2),
  quad y'_n = frac(y_(n+1) - y_(n-1), 2h) + O(h^2),
$

Подставляя в уравнение, получим,
$
  frac(y_(n+1) - 2 y_n + y_(n-1), h^2)
  + 3 frac(y_(n+1) - y_(n-1), 2h)
  - 5 y_n = 2 x_n,
  quad n = 1, 2.
$

При аппроксимации производных, входящих в граничные условия, будем
использовать односторонние разности первого порядка
$
  y'_n = frac(y_(n+1) - y_n, h) + O(h),
  quad y'_n = frac(y_n - y_(n-1), h) + O(h),
$

для левой и правой границ соответственно:
$
  y_0 + 2 frac(y_1 - y_0, h) = 0,
  quad y_3 - frac(y_3 - y_2, h) = 1.
$

Запишем для полученной разностной схемы разностный оператор:
$
  L_h y^(\(h\)) = cases(
    display(
      frac(y_(n+1) - 2 y_n + y_(n-1), h^2) + 3 frac(y_(n+1) - y_(n-1), 2h) - 5 y_n\,
      quad n = overline(1\,2)
    )\;,
    display(y_0 + 2 frac(y_1 - y_0, h))\;,
    display(y_3 - frac(y_3 - y_2, h)).,
  )
  quad quad quad
  f_h (x^(\(h\))) = cases(
    display(2 x_n\, &quad n = overline(1\,2))\;,
    0\;,
    1.,
  )
$

Аппроксимация дифференциального уравнения выполнена со вторым порядком точности.
Аппроксимация краевого условия на границах $(n=0,3)$ выполнена с первым порядком
точности, т.к. для производной использовался шаблон с первым порядком аппроксимации.
Следовательно, разностная схема имеет первый порядок аппроксимации.

Таким образом, будем иметь систему уравнений, где неизвестными являются
$y_0, y_1, y_2, y_3$:
$
  cases(
    display(y_0 + 2 frac(y_1 - y_0, 1 slash 3) = 0)\;,
    display(frac(y_2 - 2 y_1 + y_0, 1 slash 9)
    + 3 frac(y_2 - y_0, 2 slash 3) - 5 y_1 = 2 dot 1/3)\;,
    display(frac(y_3 - 2 y_2 + y_1, 1 slash 9)
    + 3 frac(y_3 - y_1, 2 slash 3) - 5 y_2 = 2 dot 2/3)\;,
    display(y_3 - frac(y_3 - y_2, 1 slash 3) = 1).,
  )
  quad ==> quad
  cases(
    gap: #1em,
    display(-5 y_0 + 6 y_1 = 0)\;,
    display(9/2 y_0 - 23 y_1 + 27/2 y_2 = 2/3)\;,
    display(9/2 y_1 - 23 y_2 + 27/2 y_3 = 4/3)\;,
    display(3 y_2 - 2 y_3 = 1).,
  )
  quad
  #{
    show math.frac: it => $it.num slash it.denom$
    $
      mat(
        -5, 6, 0, 0;
        9/2, -23, 27/2, 0;
        0, 9/2, -23, 27/2;
        0, 0, 3, -2;
      )
      vec(y_0, y_1, y_2, y_3)
      = vec(0, 2/3, 4/3, 1)
    $
  }
$

#set math.equation(numbering: "(1)")

Проверим достаточное условие корректности и устойчивости метода прогонки.
\ Пусть коэффициенты СЛАУ удовлетворяют условиям:
$ |b_i| &>= |a_i| + |c_i|, &quad i = overline(0\,n); $
$ |b_i| &> |a_i|, &quad i = overline(1\,n). $

#set math.equation(numbering: none)

т.е. матрица СЛАУ имеет диагональное преобладание. Тогда гарантируется корректность и устойчивость метода прогонки.
\
Проверим условия (1):
$
  &i = 0: &&|b_0| = -5 &&>= |a_0| + |c_0| = 6 &&"(не выполнено)";
  \ &i = 3: &&|b_3| = 2 &&>= |a_3| + |c_3| = 3 &&"(не выполнено)".
$

Достаточное условие не выполняется.

#set enum(numbering: it => strong[Ответ:])
+ Построена разностная схема первого порядка аппроксимации.
  Получена система линейных алгебраических уравнений с трехдиагональной
  матрицей. Достаточное условие корректности и устойчивости метода
  прогонки не выполняется.

#par([])

//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
*№ 2.*
$""
  quad y'' - 5 y' - 7 y = 3 x, x in [0,1]
  quad y(0) = 1,
  quad y(1) = 3.$

Запишем дифференциальный оператор и правую часть задачи:

$
  L y = cases(
    gap: #8pt,
    display(dv(y, x, 2) - 5 dv(y, x) - 7 y\, &quad x in (0,1))\;,
    y(0)\, &quad x = 0\;,
    y(1)\, &quad x = 1.,
  )
  quad quad quad
  f(x) = cases(
    display(3 x\, &quad x in (0,1))\;,
    1\, &quad x = 0\;,
    3\, &quad x = 1,
  )
$

Разобьем область изменения переменной $x in [0,3]$ на три отрезка:

#align(center)[
  #import cetz.draw
  #let tick(num, pos) = (
    pos: pos,
    draw: {
      draw.content((0, 40), $#num$, anchor: "south", padding: (bottom: 0.4))
      draw.line((90deg, -5), (90deg, +5))
      draw.content((0, 0), $y_#num$, anchor: "south", padding: (bottom: 0.4))
      draw.content(
        (0, 0),
        if str(hh.num * num / hh.denom).len() > 10 {
          $#(hh.num * num) slash #hh.denom$
        } else {
          $#(hh.num * num / hh.denom)$
        },
        anchor: "north",
        padding: (top: 0.4),
      )
      draw.content((0, -30), $x_#num$, anchor: "north", padding: (top: 0.4))
    },
  )
  #diagram(
    node((-0.56, -0.7))[Номера узлов],
    node((-0.7, -0.25))[Сеточная функция],
    node((-0.51, 0.754))[Переменная],
    edge(
      (0, 0.1),
      (12, 0.1),
      marks: (
        tick(0, 0.065),
        tick(1, 0.354),
        tick(2, 0.644),
        tick(3, 0.934),
        (inherit: "solid"),
      ),
    ),
  )
]

Составим разностную схему для уравнения во внутренних узлах сетки
используя центральные разности второго порядка аппроксимации:
$
  y''_n = frac(y_(n+1) - 2 y_n + y_(n-1), h^2) + O(h^2),
  quad y'_n = frac(y_(n+1) - y_(n-1), 2h) + O(h^2),
$

Подставляя в уравнение, получим,
$
  frac(y_(n+1) - 2 y_n + y_(n-1), h^2)
  - 5 frac(y_(n+1) - y_(n-1), 2h)
  - 7 y_n = 3 x_n,
  quad n = 1, 2.
$

Запишем для полученной разностной схемы разностный оператор:
$
  L_h y^(\(h\)) = cases(
    display(
      frac(y_(n+1) - 2 y_n + y_(n-1), h^2)
        - 5 frac(y_(n+1) - y_(n-1), 2h)
        - 7 y_n\,
      quad n = overline(1\,2)
    )\;,
    display(y_0)\;,
    display(y_3).,
  )
  quad quad quad
  f_h (x^(\(h\))) = cases(
    display(3 x_n\, &quad n = overline(1\,2))\;,
    1\;,
    3.,
  )
$

Аппроксимация дифференциального уравнения выполнена со вторым порядком точности.
Краевое условие на границах выполняется точно.
Следовательно, разностная схема имеет второй порядок аппроксимации.

Таким образом, будем иметь систему уравнений, где неизвестными являются
$y_0, y_1, y_2, y_3$:
$
  cases(
    gap: #1em,
    display(y_0 = 1)\;,
    display(frac(y_2 - 2 y_1 + y_0, 1 slash 9)
    - 5 frac(y_2 - y_0, 2 slash 3)
    - 7 y_1 = 3 dot 1/3)\;,
    display(frac(y_3 - 2 y_2 + y_1, 1 slash 9)
    - 5 frac(y_3 - y_1, 2 slash 3)
    - 7 y_2 = 3 dot 2/3)\;,
    display(y_3 = 3).,
  )
  quad ==> quad
  cases(
    gap: #1em,
    display(y_0 = 1)\;,
    display(33/2 y_0 - 25 y_1 + 3/2 y_2 = 1)\;,
    display(33/2 y_1 - 25 y_2 + 3/2 y_3 = 2)\;,
    display(y_3 = 3).,
  )
  quad
  #{
    show math.frac: it => $it.num slash it.denom$
    $
      mat(
        1, 0, 0, 0;
        33/2, -25, 3/2, 0;
        0, 33/2, -25, 3/2;
        0, 0, 0, 1;
      )
      vec(y_0, y_1, y_2, y_3)
      = vec(1, 1, 2, 3)
    $
  }
$

#set math.equation(numbering: "(1)")

Проверим достаточное условие корректности и устойчивости метода прогонки.
\ Пусть коэффициенты СЛАУ удовлетворяют условиям:
$ |b_i| &>= |a_i| + |c_i|, &quad i = overline(0\,n); $
$ |b_i| &> |a_i|, &quad i = overline(1\,n). $

#set math.equation(numbering: none)

т.е. матрица СЛАУ имеет диагональное преобладание. Тогда гарантируется корректность и устойчивость метода прогонки.
\
Проверим условия (1):
$
  &i = 0: &&|b_0| = 1 &&>= |a_0| + |c_0| = 0 &&"(выполнено)";
  \ &i = 1: &&|b_1| = 25 &&>= |a_1| + |c_1| = 18 &&"(выполнено)";
  \ &i = 2: &&|b_2| = 25 &&>= |a_2| + |c_2| = 18 &&"(выполнено)";
  \ &i = 3: &&|b_3| = 1 &&>= |a_3| + |c_3| = 0 &&"(выполнено)".
$

Проверим условия (2):
#{
  show math.frac: it => $it.num slash it.denom$
  $
    &i = 1: &&|b_1| = 25 &&> |a_1| = 33 / 2 &&"(выполнено)";
    \ &i = 2: &&|b_2| = 25 &&> |a_2| = 33 / 2 &&"(выполнено)";
    \ &i = 3: &&|b_3| = 1 &&> |a_3| = 0 &&"(выполнено)".
  $
}
Достаточное условие выполняется.

#set enum(numbering: it => strong[Ответ:])
+ Построена разностная схема второго порядка аппроксимации.
  Получена система линейных алгебраических уравнений с трехдиагональной
  матрицей, для решения которой применим метод прогонки. \
